<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[IOS pop到指定页面]]></title>
      <url>%2F2017%2F03%2F01%2FIOS-pop%E5%88%B0%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[IOS pop到指定页面for (UIViewController *controller in self.navigationController.viewControllers) &#123; if ([controller isKindOfClass:[MSViewController class]]) &#123; MSViewController *vc =(MSViewController *)controller; [self.navigationController popToViewController:vc animated:YES]; &#125; &#125; 以上代码的意思是当前界面栈中是否有MSViewController，如果有的话，就会pop到MSViewController，假设当前界面为A界面，那么A界面和MSViewController之间的所有界面都会出栈。MSViewController界面就会在栈顶。所以这就是for循环遍历的过程。[self.navigationController popToViewController:self.navigationController.viewControllers[self.navigationController.viewControllers.count - 3] animated:YES]; 还有一种方式这个必须得有tableBar[self.tabBarController setSelectedIndex:3]; [self.navigationController popToRootViewControllerAnimated:YES];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IOS属性]]></title>
      <url>%2F2017%2F03%2F01%2FIOS%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[@property与@synthesizeproperty属性提供成员变量的访问方法的声明、控制成员变量的访问权限、控制多线程时成员变量的访问环境。 property不但可以在interface，在协议protocol.和类别category中也可以使用。 synthesize 合成访问器方法实现property所声明的方法的定义。其实说直白就像是：property声明了一些成员变量的访问方法，synthesize则定义了由property声明的方法。 他们之前的对应关系是:property 声明方法 -&gt;头文件中申明getter和setter方法 synthesize定义方法 -&gt; m文件中实现getter和setter方法。 在Xcode4.5及以后的版本中，可以省略@synthesize，编译器会自动帮你加上get 和 set 方法的实现，并且默认会去访问_age这个成员变量，如果找不到_age这个成员变量，会自动生成一个叫做 _age的私有成员变量。在.m文件中同时实现getter和setter时候需要@synthesize age = _age. 读写特性：readonly 、readwrite在Objective-C中，拥有这样两个读写特性：readwrite和readonly，意思简单明了，就是可读可写以及只读。默认情况下，属性默认是可读可写的。 强引用与弱引用的广义区别： 强引用也就是我们通常所讲的引用，其存亡直接决定了所指对象的存亡。如果不存在指向一个对象的引用，并且此对象不再显示列表中，则此对象会被从内存中释放。 弱引用除了不决定对象的存亡外，其他与强引用相同。即使一个对象被持有无数个若引用，只要没有强引用指向他，那麽其还是会被清除。面对ARC机制中，最令人头疼的就是“循环强引用”的问题，所谓循环强引用，就是我们申请了两个保险柜，然后分别将另外一个保险柜的钥匙锁在了保险柜当中。这样就会造成什么现象呢？我们完全就无法归还钥匙了，这两个保险柜就无法再重新使用了。那么使用弱引用，就不会出现这个问题了。 weak常用于网络delegate属性 原子特性 原子特性，简要来说，是针对多线程而设置的。Objective-C拥有两种原子特性，分别是atomic和nonatomic。我们知道，如果使用多线程的话，有时会出现两个线程互相等待而导致的死锁现象。使用atomic特性，Objective-C可以防止这种线程互斥的情况发生，但是会造成一定的资源消耗。这个特性是默认的。而如果使用nonatomic，就不会有这种阻止死锁的功能，但是如果我们确定不使用多线程的话，那么使用这个特性可以极大地改善应用性能。相比之下，swift目前还不支持这些特性。如果我们要实现线程安全，似乎只能使用objc_sync_enter此类的方法，来保证属性的处理只有一个线程在进行。或者使用属性观察器来完成这些操作。 辛苦网上找的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IOS核心动画]]></title>
      <url>%2F2017%2F03%2F01%2FIOS%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[核心动画根据一个矩形画曲线+ (UIBezierPath *)bezierPathWithRect:(CGRect)rect 根据矩形框的内切圆画曲线+ (UIBezierPath *)bezierPathWithOvalInRect:(CGRect)rect 根据矩形画带圆角的曲线+ (UIBezierPath *)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius 在矩形中，可以针对四角中的某个角加圆角+ (UIBezierPath *)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii参数：corners:枚举值，可以选择某个角cornerRadii:圆角的大小 以某个中心点画弧线+ (UIBezierPath *)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;参数：center:弧线中心点的坐标radius:弧线所在圆的半径startAngle:弧线开始的角度值endAngle:弧线结束的角度值clockwise:是否顺时针画弧线 画二元曲线，一般和moveToPoint配合使用- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint参数：endPoint:曲线的终点controlPoint:画曲线的基准点 以三个点画一段曲线，一般和moveToPoint配合使用- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2参数：endPoint:曲线的终点controlPoint1:画曲线的第一个基准点controlPoint2:画曲线的第二个基准点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IOS传值]]></title>
      <url>%2F2017%2F02%2F23%2FIOS%E4%BC%A0%E5%80%BC%2F</url>
      <content type="text"><![CDATA[ios传值iOS七种传值总结（关键代码）ViewController = 启动后的主界面ZQMainVC = 主界面中的二级界面ZQResignVC = 主界面中的二级界面ZQShareManager = 单例的类RedView = ViewController的子View 初始化传值：适用上一级界面往下一级界面传值 ViewController-&gt; ZQMainVC=============ZQMainVC类============ //写个类似构造函数的方法 @implementationZQMainVC -(id)initWithUserName:(NSString*)userName WithPassWord:(NSString *)passWord &#123; self = [super init]; if (self) &#123; _passWord=passWord; _userName=userName; &#125; return self; &#125; =============ViewController类============= //调用传值处 ZQMainVC *mainVC=[[ZQMainVC alloc]initWithUserName:_userNameText.textWithPassWord:_passWordText.text]; [self.navigationController pushViewController:mainVC animated:YES]; 属性传值：只适用于上级界面对下一级界面的跳转赋值 ViewController-&gt; ZQMainVC和初始化传值比较，代码可读性低=============ViewController类============= ZQMainVC *mainVC=[[ZQMainVC alloc]init];//直接对属性赋值, mainVC.userName=_userNameText.text; mainVC.passWord=_passWordText.text; [self.navigationController pushViewController:mainVC animated:YES]; ##代理传值：适合下一级界面回传值给上一级 ZQResignVC-&gt; ViewController=============ZQResignVC类============= //写代理方法 @protocolZQResignVCDelegate &lt;NSObject&gt; -(void)sendMessage:(NSString*)userName withPassword:(NSString *)password; @end //定义属性 @property(nonatomic,assign)id&lt;ZQResignVCDelegate&gt;delegate; //调用处 -(void)buttonClick:(UIButton*)button&#123; if (self.delegate&amp;&amp;[self.delegaterespondsToSelector:@selector(sendMessage:withPassword:)]) &#123; [self.delegate sendMessage:_userNameText.textwithPassword:_passWordText.text]; &#125; &#125; =============ViewController类============= ZQResignVC *resignVC=[[ZQResignVC alloc]init];// 设置代理 resignVC.delegate=self; [self.navigationController pushViewController:resignVC animated:YES]; 单例传值：对没有跳转关系的两个controller进行传值（有拿Appdelegate当单例的用法，一个意思，区别在于Appdelegate中一大堆的属性。。。乱）============= ZQShareManager=============@interface ZQShareManager : NSObject@property (copy, nonatomic) NSString *userName;@property (copy, nonatomic) NSString *password;// 申明一个类方法+ (ZQShareManager *)shareUserInfo;@end@implementation ZQShareManager+ (ZQShareManager *)shareUserInfo&#123; static ZQShareManager *shareManager = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; shareManager = [[self alloc] init]; &#125;); return shareManager;&#125;@end 怎么用就不写了，在想保存的地方对ZQShareManager的属性赋值，在想用的地方调用ZQShareManager中的属性 NSuserDefault传值：对没有跳转关系的两个controller进行传值（类似弄个sqlite数据库传值了，或写个文件传值，区别单例在于，应用被kill后再次启动还有值，而上面的单例重启应用后，就木有值了）=============ViewController类=============-(void)buttonClick:(UIButton *)button&#123;// 赋值保存 [[NSUserDefaults standardUserDefaults]setValue:_userNameText.text forKey:@"UserId"]; [[NSUserDefaults standardUserDefaults]setValue:_passWordText.text forKey:@"PassWord"];// 写入NSUserDefaults [[NSUserDefaults standardUserDefaults]synchronize]; ZQMainVC *mainVC=[[ZQMainVC alloc]init]; [self.navigationController pushViewController:mainVC animated:YES]; &#125; =============ZQMainVC类============// 需要用到的地方取出NSUserDefaults中的值 self.userName=[[NSUserDefaults standardUserDefaults]objectForKey:@"UserId"]; self.passWord=[[NSUserDefaults standardUserDefaults]objectForKey:@"PassWord"]; 通知传值：对没有跳转关系的两个controller进行传值，这个要用的话一定要谨慎，主要用在线程中，比如下载东西，你都不知道什么时候会触发下载完的时候，才考虑用发通知的方式，这东西用多了，代码可读性变得非常差=============ZQResignVC类=============// 点击按钮发送通知-(void)buttonClick:(UIButton *)button&#123;[self textResignFirstResponder]; /***************通知传值****************/ NSArray *array=[[NSArray alloc]initWithObjects:_userNameText.text,_passWordText.text, nil]; //发送通知 sendMessage表示通知详情 array表示传输数据 [[NSNotificationCenter defaultCenter] postNotificationName:@"ZQSendMessage" object:array]; /*****************通知传值****************/ [self.navigationController popToRootViewControllerAnimated: YES];&#125; ============= ViewController =============//-viewDidLoad方法中注册接受通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(getZQMessage:) name:@"ZQSendMessage" object:nil];//解析通知中的数据赋值-(void)getZQMessage:(NSNotification *)notification&#123; NSArray *array=[[NSArray alloc]initWithArray:notification.object]; _userNameText.text=array[0]; _passWordText.text=array[1]; &#125;// 记得界面如果界面销毁移除掉通知监听-(void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; block传值：适用于子界面中的点击事件回传，比在子界面写一大堆delegeta要看着方便，用于子线程回调也OK=============RedView=============@class RedView;typedef void(^TouchButton)(RedView *);@interface RedView : UIView@property(nonatomic,copy)TouchButton block;@property(nonatomic,retain) NSString *title;@end@interface RedView()&#123; UIButton *button;&#125;@end@implementation RedView- (id)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; button = [UIButton buttonWithType:UIButtonTypeSystem]; [button addTarget:self action:@selector(buttonClick:) forControlEvents:UIControlEventTouchUpInside]; button.frame = frame; button.backgroundColor = [UIColor redColor]; [self addSubview:button]; &#125; return self;&#125;-(void)buttonClick:(id)sender&#123; NSLog(@"点击"); _title = @"装请带上我飞"; _block(self);&#125;@end =============ViewController=============RedView *rView = [[RedView alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; rView.block = ^(RedView *button)&#123;// 注意block的循环引用问题 title.text = button.title; &#125;; 以上是今天项目遇到的一些，比较纠结，不知道用哪种比较好，就总结了一下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IOS定时器]]></title>
      <url>%2F2017%2F02%2F22%2FIOS%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
      <content type="text"><![CDATA[ios定时器NSTimerUIScrollView 拖动时执行的是 UITrackingRunLoopMode，会导致暂停定时器，等恢复为 NSDefaultRunLoopMode 时才恢复定时器。所以如果需要定时器在 UIScrollView 拖动时也不影响的话，建议添加到 UITrackingRunLoopMode 或 NSRunLoopCommonModes 中： NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];[[NSRunLoop mainRunLoop] addTimer:timer forMode: UITrackingRunLoopMode]; ///&lt; 或者 NSRunLoopCommonModes GCD方式NSTimeInterval period = 1.0; //设置时间间隔dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0); //每秒执行dispatch_source_set_event_handler(_timer, ^&#123; //在这里执行事件 &#125;);dispatch_resume(_timer); CADisplayLink创建方法self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink:)]; [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; 停止方法[self.displayLink invalidate]; self.displayLink = nil; /**当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于重复的NSTimer被启动了；执行invalidate操作时，CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。**/ 特性屏幕刷新时调用CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。所以通常情况下，按照iOS设备屏幕的刷新率60次/秒延迟iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会。如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。使用场景从原理上可以看出，CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。 重要属性frameIntervalNSInteger类型的值，用来设置间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。durationreadOnly的CFTimeInterval值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：调用间隔时间 = duration × frameInterval。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符串的一些方法]]></title>
      <url>%2F2017%2F02%2F22%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[字符串的一些方法全局被我使用的字符串：NSString *string = @"街上,走着一个女孩，好清秀,牵着人们的眼球,就象,花儿一样可爱,好温柔,看也看不够"; 截取字符串的 第10个(包括第10个) 之前字符NSString *stringOne = [string substringToIndex:10];NSLog(@"stringOne = %@",stringOne); 截取字符串的 第10个(包括第10个) 之后字符NSString *stringTwo = [string substringFromIndex:10];NSLog(@"stringTwo = %@",stringTwo); 截图字符串第4个（但不包括第4个）后的4位 NSString* stringOne =[string substringWithRange:NSMakeRange(4, 2)];NSLog(@"stringOne = %@",stringOne); 字符串的替换（也可以相当于删除用“”替换）stringOne = [stringOne stringByReplacingOccurrencesOfString:@":" withString:@""];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见的error]]></title>
      <url>%2F2017%2F02%2F22%2F%E5%B8%B8%E8%A7%81%E7%9A%84error%2F</url>
      <content type="text"><![CDATA[常见的erroor]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[保存视频]]></title>
      <url>%2F2017%2F02%2F21%2F%E4%BF%9D%E5%AD%98%E8%A7%86%E9%A2%91%2F</url>
      <content type="text"><![CDATA[保存视频//部分代码，注意文件夹后缀加上保存文件的类型，比如mp3、mp4、（本人深有体会，因为没加后缀，搞了好长时间） [self writeToCachePath:downloadData time:media.timeCreated];//数据写入缓存- (void)writeToCachePath:(id)cacheData time:(NSString*)createTime &#123; NSString * documentsDirectory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]; createTime = [createTime stringByReplacingOccurrencesOfString:@"-" withString:@""]; createTime = [createTime stringByReplacingOccurrencesOfString:@"/" withString:@""]; createTime = [createTime stringByReplacingOccurrencesOfString:@" " withString:@""]; NSString* videoCachePath = [documentsDirectory stringByAppendingPathComponent:[NSString stringWithFormat:@"videodingxu/%@.mp4",createTime]]; [cacheData writeToFile:videoCachePath atomically:YES]; &#125; //下面这段代码是去除多余的标点符号 createTime = [createTime stringByReplacingOccurrencesOfString:@"-" withString:@""];createTime = [createTime stringByReplacingOccurrencesOfString:@"/" withString:@""];createTime = [createTime stringByReplacingOccurre]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[@把图片保存到相册]]></title>
      <url>%2F2017%2F02%2F14%2F%E6%8A%8A%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98%E5%88%B0%E7%9B%B8%E5%86%8C%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 把图片保存到相册有的是通过image保存，这个丢失了图片的一些信息，比如拍摄时的位置（我们有个需求，就是保存图片时，必须得有地址信息，坑爹的需求，不过机智的我找到了方法） 第一种- (void)loadImageFinished:(UIImage *)image&#123; UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), (__bridge void *)self);&#125;- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo&#123; NSLog(@"image = %@, error = %@, contextInfo = %@", image, error, contextInfo);&#125; 第一个参数是要保存到相册的图片对象 第二个参数是保存完成后回调的目标对象 第三个参数就是保存完成后回调到目标对象的哪个方法中，方法的声明要如代码中所示的： - (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo; 第四个参数在保存完成后，会原封不动地传回到回调方法的contextInfo参数中。 第二种使用AssetsLibrary框架中的ALAssetsLibrary类来实现。具体代码如下： - (void)loadImageFinished:(UIImage *)image&#123; __block ALAssetsLibrary *lib = [[ALAssetsLibrary alloc] init]; [lib writeImageToSavedPhotosAlbum:image.CGImage metadata:nil completionBlock:^(NSURL *assetURL, NSError *error) &#123; NSLog(@"assetURL = %@, error = %@", assetURL, error); lib = nil; &#125;];&#125; 使用了ALAssetsLibrary类的writeImageToSavedPhotosAlbum:metadata:completionBlock:方法实现。其中第一个参数是一个CGImageRef的对象，表示要传入的图片。第二个参数是图片的一些属性，这里没有设置所以传入nil。最后一个completionBlock是保存完成后的回调，在这个回调中可以取到保存后的图片路径以及保存失败时的错误信息。 注意：使用该类时需要导入AssetsLibrary.framework。而且该类需要在iOS4.0以上可以使用，但是在iOS9.0之后就被标记为过时方法。官方建议使用Photos.framework中的PHPhotoLibrary进行代替，也就是下面所说的第三种方法。 第三种这个是直接保存data的可以达到要求,能把图片的一些属性一起存到本地__block ALAssetsLibrary *lib = [[ALAssetsLibrary alloc] init]; [lib writeImageDataToSavedPhotosAlbum:downloadData metadata:nil completionBlock:nil]; 第四种使用Photos框架的PHPhotoLibrary类来实现保存到相册功能。代码如下： - (void)loadImageFinished:(UIImage *)image&#123; [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123; /写入图片到相册 PHAssetChangeRequest *req = [PHAssetChangeRequest creationRequestForAssetFromImage:image]; &#125; completionHandler:^(BOOL success, NSError * _Nullable error) &#123; NSLog(@"success = %d, error = %@", success, error); &#125;];&#125; 该例子中先调用PHPhotoLibrary类的performChanges:completionHandler:方法，然后在它的changeBlock中，通过PHAssetChangeRequest类的creationRequestForAssetFromImage:方法传入一个图片对象即可实现保存到相册的功能。然后completionHandler中会告诉我们是否操作成功。 进阶使用：得到保存到相册的图片对象 也许会有人需要在保存相册后得到图片的PHAsset对象来进行后续操作（昨天刚好碰到有朋友遇到这样的问题）。那么，这里对上面例子进行改进，在创建PHAssetChangeRequest后将它的placeholderForCreatedAsset属性的localIdentifier属性保存到一个数组中，等待操作完成后再通过这个数组来查找刚刚添加的图片对象。请看下面例子： - (void)loadImageFinished:(UIImage *)image&#123; NSMutableArray *imageIds = [NSMutableArray array]; [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123; //写入图片到相册 PHAssetChangeRequest *req = [PHAssetChangeRequest creationRequestForAssetFromImage:image]; //记录本地标识，等待完成后取到相册中的图片对象 [imageIds addObject:req.placeholderForCreatedAsset.localIdentifier]; &#125; completionHandler:^(BOOL success, NSError * _Nullable error) &#123; NSLog(@"success = %d, error = %@", success, error); if (success) &#123; //成功后取相册中的图片对象 __block PHAsset *imageAsset = nil; PHFetchResult *result = [PHAsset fetchAssetsWithLocalIdentifiers:imageIds options:nil]; [result enumerateObjectsUsingBlock:^(PHAsset * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; imageAsset = obj; *stop = YES; &#125;]; if (imageAsset) &#123; //加载图片数据 [[PHImageManager defaultManager] requestImageDataForAsset:imageAsset options:nil resultHandler:^(NSData * _Nullable imageData, NSString * _Nullable dataUTI, UIImageOrientation orientation, NSDictionary * _Nullable info) &#123; NSLog("imageData = %@", imageData); &#125;]; &#125; &#125; &#125;];&#125; 总结第一种方式是最常用的，使用起来很方便，传入UIImage就可以了，也不需要担心iOS不同版本的问题。唯一缺点就是无法找到对应添加的图片。 第二三种方式是iOS4之后加入的，在iOS9后又不推荐使用了。他也提供了很直观的方式来保存图片，并且也能够取到保存后相对应的图片路径。 第四种方式是iOS8之后加入的，他的使用稍微复杂一点，但是它允许进行批量的操作，例如添加、修改、删除等。如果要做更近复杂的操作的话，这种方式是比较推荐的方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS常用的判断方法]]></title>
      <url>%2F2017%2F02%2F14%2FiOS%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 ios常用的一些判断根据日起计算是周几+ (NSString*)weekdayStringFromDate:(NSDate*)inputDate&#123; NSArray *weekdays = [NSArray arrayWithObjects: [NSNull null], @"周日", @"周一", @"周二", @"周三", @"周四", @"周五", @"周六", nil]; NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar]; NSTimeZone *timeZone = [[NSTimeZone alloc] initWithName:@"Asia/Shanghai"]; [calendar setTimeZone: timeZone]; NSCalendarUnit calendarUnit = NSWeekdayCalendarUnit; NSDateComponents *theComponents = [calendar components:calendarUnit fromDate:inputDate];return [weekdays objectAtIndex:theComponents.weekday];&#125; 把时间戳转化为字符串传个时间转化为字符串+ (NSString *)dateStringFromNumberTimer:(NSString *)timerStr &#123; //转化为Double double t = [timerStr doubleValue]; //计算出距离1970的NSDate NSDate *date = [NSDate dateWithTimeIntervalSince1970:t]; //转化为 时间格式化字符串 //NSDateFormatter *df = [[[NSDateFormatter alloc] init] autorelease]; NSDateFormatter *df = [[NSDateFormatter alloc] init]; df.dateFormat = @"yyyy-MM-dd HH:mm:ss"; //转化为 时间字符串 return [df stringFromDate:date];&#125; 计算时间差获得当前系统时间到指定时间的时间差字符串,传入目标时间字符串和格式 +(NSString*)stringNowToDate:(NSString*)toDate formater:(NSString*)formatStr&#123;NSDateFormatter *formater=[[NSDateFormatter alloc] init];if (formatStr) &#123; [formater setDateFormat:formatStr];&#125;else&#123; [formater setDateFormat:[NSString stringWithFormat:@"yyyy-MM-dd HH:mm:ss"]];&#125;NSDate *date=[formater dateFromString:toDate];return [self stringNowToDate:date];&#125; 获得到指定时间的时间差字符串,格式在此方法内返回前自己根据需要格式化 +(NSString*)stringNowToDate:(NSDate*)toDate&#123; //创建日期 NSCalendar对象 NSCalendar *cal = [NSCalendar currentCalendar]; //得到当前时间 NSDate *today = [NSDate date];//用来得到具体的时差,位运算unsigned int unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit ;if (toDate &amp;&amp; today) &#123;//不为nil进行转化 NSDateComponents *d = [cal components:unitFlags fromDate:today toDate:toDate options:0 ]; //NSString *dateStr=[NSString stringWithFormat:@"%d年%d月%d日%d时%d分%d秒",[d year],[d month], [d day], [d hour], [d minute], [d second]]; NSString *dateStr=[NSString stringWithFormat:@"%02ld:%02ld:%02ld",[d hour], [d minute], [d second]]; return dateStr;&#125;return @"";&#125; 动态计算行高根据字符串的实际内容大小，在固定的宽度和大小的情况下，动态计算行高 + (CGFloat)textHeightFromTextString:(NSString *)text width:(CGFloat)textWidth fontSize:(CGFloat)size&#123; if ([MZLUtility getCurrentIOS] &gt;= 7.0) &#123; //iOS7之后 /* 第一个参数: 预设空间 宽度固定 高度预设 一个最大值 第二个参数: 行间距 如果超出范围是否截断 第三个参数: 属性字典 可以设置字体大小 */ NSDictionary *dict = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:size]&#125;; CGRect rect = [text boundingRectWithSize:CGSizeMake(textWidth, MAXFLOAT) options:NSStringDrawingTruncatesLastVisibleLine|NSStringDrawingUsesFontLeading|NSStringDrawingUsesLineFragmentOrigin attributes:dict context:nil]; //返回计算出的行高 return rect.size.height; &#125;else &#123; //iOS7之前 /* 1.第一个参数 设置的字体固定大小 2.预设 宽度和高度 宽度是固定的 高度一般写成最大值 3.换行模式 字符换行 */ CGSize textSize = [text sizeWithFont:[UIFont systemFontOfSize:size] constrainedToSize:CGSizeMake(textWidth, MAXFLOAT) lineBreakMode:NSLineBreakByCharWrapping]; return textSize.height;//返回 计算出得行高 &#125;&#125; 获取iOS的版本号+ (double)getCurrentIOS &#123; return [[[UIDevice currentDevice] systemVersion] doubleValue];&#125;+ (CGSize)getScreenSize &#123; return [[UIScreen mainScreen] bounds].size;&#125; 目录找到沙盒的路径+ (NSString *)getFullPathWithFile:(NSString *)urlName &#123;//先获取 沙盒中的Library/Caches/路径NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];NSString *myCacheDirectory = [docPath stringByAppendingPathComponent:@"MyCaches"];//检测MyCaches 文件夹是否存在if (![[NSFileManager defaultManager] fileExistsAtPath:myCacheDirectory]) &#123; //不存在 那么创建 [[NSFileManager defaultManager] createDirectoryAtPath:myCacheDirectory withIntermediateDirectories:YES attributes:nil error:nil];&#125;//用md5进行 加密 转化为 一串十六进制数字 (md5加密可以把一个字符串转化为一串唯一的用十六进制表示的串)NSString * newName = MD5Hash(urlName);//拼接路径return [myCacheDirectory stringByAppendingPathComponent:newName];&#125; 清除缓存+ (void) resetCache &#123; [[NSFileManager defaultManager] removeItemAtPath:[MZLCache cacheDirectory] error:nil];&#125; 缓存目录+ (NSString*) cacheDirectory &#123; NSArray* paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString *cacheDirectory = [paths objectAtIndex:0]; cacheDirectory = [cacheDirectory stringByAppendingPathComponent:@"MZLCaches"]; return cacheDirectory;&#125; 删除指定的缓存+ (NSData*) objectForKey:(NSString*)key &#123; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *filename = [self.cacheDirectory stringByAppendingPathComponent:key]; if ([fileManager fileExistsAtPath:filename]) &#123; NSDate *modificationDate = [[fileManager attributesOfItemAtPath:filename error:nil] objectForKey:NSFileModificationDate]; if ([modificationDate timeIntervalSinceNow] &gt; cacheTime) &#123; [fileManager removeItemAtPath:filename error:nil]; &#125; else &#123; NSData *data = [NSData dataWithContentsOfFile:filename]; return data; &#125; &#125; return nil;&#125; 创建指定的缓存+ (void) setObject:(NSData*)data forKey:(NSString*)key &#123; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *filename = [self.cacheDirectory stringByAppendingPathComponent:key]; BOOL isDir = YES; if (![fileManager fileExistsAtPath:self.cacheDirectory isDirectory:&amp;isDir]) &#123; [fileManager createDirectoryAtPath:self.cacheDirectory withIntermediateDirectories:NO attributes:nil error:nil]; &#125; NSError *error; @try &#123; [data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]; &#125; @catch (NSException * e) &#123; //TODO: error handling maybe &#125;&#125; 获取某个路径下文件的大小+ (long long) fileSizeAtPath:(NSString*) filePath&#123; NSFileManager* manager = [NSFileManager defaultManager]; if ([manager fileExistsAtPath:filePath])&#123; return [[manager attributesOfItemAtPath:filePath error:nil] fileSize];&#125;return 0;&#125; 获取缓存的大小+ (float ) folderSizeAtPath:(NSString*) folderPath&#123; NSFileManager* manager = [NSFileManager defaultManager]; if (![manager fileExistsAtPath:folderPath]) return 0; NSEnumerator *childFilesEnumerator = [[manager subpathsAtPath:folderPath] objectEnumerator]; NSString* fileName; long long folderSize = 0; while ((fileName = [childFilesEnumerator nextObject]) != nil)&#123; NSString* fileAbsolutePath = [folderPath stringByAppendingPathComponent:fileName]; folderSize += [MZLCache fileSizeAtPath:fileAbsolutePath]; &#125; return folderSize/(1024.0*1024.0);&#125; MD5加密字符串NSString * MD5Hash(NSString *aString) &#123; const char *cStr = [aString UTF8String]; unsigned char result[16]; CC_MD5( cStr, (CC_LONG)strlen(cStr), result ); return [NSString stringWithFormat:@"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X", result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7], result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15]];&#125; 正则判断手机格式的正则判断+ (BOOL)isMobileNumber:(NSString *)mobileNum&#123; /** * 手机号码 * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188 * 联通：130,131,132,152,155,156,185,186 * 电信：133,1349,153,180,189,181 * 新增：14_,17_ */ NSString * MOBIL = @"^1(3[0-9]|4[0-9]|5[0-35-9]|7[0-9]|8[025-9])\\d&#123;8&#125;$"; /** 10 * 中国移动：China Mobile 11 * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188 12 */ NSString * CM = @"^1(34[0-8]|(3[5-9]|5[017-9]|8[2378])\\d)\\d&#123;7&#125;$"; /** 15 * 中国联通：China Unicom 16 * 130,131,132,152,155,156,185,186 17 */ NSString * CU = @"^1(3[0-2]|5[256]|8[56])\\d&#123;8&#125;$"; /** 20 * 中国电信：China Telecom 21 * 133,1349,153,180,189,181(增加) 22 */ NSString * CT = @"^1((33|53|8[019])[0-9]|349)\\d&#123;7&#125;$"; /** 25 * 大陆地区固话及小灵通 26 * 区号：010,020,021,022,023,024,025,027,028,029 27 * 号码：七位或八位 28 */ // NSString * PHS = @"^0(10|2[0-5789]|\\d&#123;3&#125;)\\d&#123;7,8&#125;$"; NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", MOBIL]; NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM]; NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU]; NSPredicate *regextestct = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT]; if (([regextestmobile evaluateWithObject:mobileNum] || [regextestcm evaluateWithObject:mobileNum] || [regextestct evaluateWithObject:mobileNum] || [regextestcu evaluateWithObject:mobileNum])) &#123; return YES; &#125; return NO;&#125; 密码正则判断6-16 大小写数字+ (BOOL) isPassword:(NSString *)password;&#123; NSRegularExpression *regularexpression = [[NSRegularExpression alloc] initWithPattern:@"^[a-zA-Z0-9]&#123;6,16&#125;$" options:NSRegularExpressionCaseInsensitive error:nil]; NSUInteger numberofMatch = [regularexpression numberOfMatchesInString:password options:NSMatchingReportProgress range:NSMakeRange(0, password.length)]; if(numberofMatch &gt; 0) return YES; return NO; 邮箱的正则判断+ (BOOL) isEmail:(NSString *)email&#123; NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;"; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex]; if ([emailTest evaluateWithObject:email]) &#123; return YES; &#125; return NO;&#125; 身份证正则判断+ (BOOL) isIdentityCard: (NSString *)identityCard&#123; NSString *idnum = @"^(\\d&#123;14&#125;|\\d&#123;17&#125;)(\\d|[xX])$"; NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",idnum]; return [identityCardPredicate evaluateWithObject:identityCard];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[类别]]></title>
      <url>%2F2017%2F02%2F14%2F%E7%B1%BB%E5%88%AB%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 类别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序]]></title>
      <url>%2F2017%2F02%2F14%2F%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 数组排序取同一天NSMutableArray *dateMutablearray = [@[] mutableCopy]; NSArray *array1 = @[@"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-04",@"2014-04-06",@"2014-04-08", @"2014-04-05",@"2014-04-07",@"2014-04-09",]; NSMutableArray *array = [NSMutableArray arrayWithArray:array1]; for (int i = 0; i &lt; array.count; i ++) &#123; NSString *string = array[ i]; NSMutableArray *tempArray = [@[] mutableCopy]; [tempArray addObject:string]; for (int j = i+1; j &lt; array.count; j ++) &#123; NSString *jstring = array[j]; NSLog(@"jstring:%@",jstring); if([string isEqualToString:jstring])&#123; NSLog(@"jvalue = kvalue"); [tempArray addObject:jstring]; [array removeObjectAtIndex:j]; &#125; &#125; [dateMutablearray addObject:tempArray]; &#125;NSLog(@"array:%@",array); NSLog(@"dateMutable:%@",dateMutablearray);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客搭建]]></title>
      <url>%2F2017%2F02%2F07%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 github部分登录 注册https://github.com/Sign up : 注册sign in : 登陆 建立远程仓库注意命名格式 Github名＋.github.io 配置SSH key$ ssh-keygen -t rsa -C "这里是你Github绑定的邮箱我的是QQ邮箱@qq.com" 如果你已经配置过，会提示是否覆盖y／n，直接输入y代表覆盖，生成新的秘钥，其余return就可以。秘钥生成配置成功标志。 +—[RSA 2048]——+| ..+ o || . O.= + || . . . o.oB O o || . + o o=. * * || = o .So. + || . + . . . ||. . o . . .. || o o.o E +. . ||o .o*o. . oo |+——[SHA256]——+ 找到公钥点击mac的空白处，电脑最上面前往打开，前往文件夹，或者快捷键 shift +commond +g 前往--&gt;前往文件夹－－&gt;输入 ~/.ssh/id_rsa.pub 复制公钥，前往Github配置 博客仓库（dingxp.github.io）--&gt;点击settings --&gt;左侧 Deploy keys存在就删除，不存在就加上 刚才的公钥，key的名字随便写 关联Github后面步骤中，当你发布文章Git终端执行hexo d的时候提示 Username for 'https://github.com':Password for 'https://github.com': hexo部分安装homebrew]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[丁旭朋]]></title>
      <url>%2F2017%2F02%2F06%2F%E4%B8%81%E6%97%AD%E6%9C%8B%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F06%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
