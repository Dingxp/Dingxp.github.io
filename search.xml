<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[@把图片保存到相册]]></title>
      <url>%2F2017%2F02%2F14%2F%E6%8A%8A%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98%E5%88%B0%E7%9B%B8%E5%86%8C%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 把图片保存到相册有的是通过image保存，这个丢失了图片的一些信息，比如拍摄时的位置（我们有个需求，就是保存图片时，必须得有地址信息，坑爹的需求，不过机智的我找到了方法） 第一种- (void)loadImageFinished:(UIImage *)image&#123; UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), (__bridge void *)self);&#125;- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo&#123; NSLog(@"image = %@, error = %@, contextInfo = %@", image, error, contextInfo);&#125; 第一个参数是要保存到相册的图片对象 第二个参数是保存完成后回调的目标对象 第三个参数就是保存完成后回调到目标对象的哪个方法中，方法的声明要如代码中所示的： - (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo; 第四个参数在保存完成后，会原封不动地传回到回调方法的contextInfo参数中。 第二种使用AssetsLibrary框架中的ALAssetsLibrary类来实现。具体代码如下： - (void)loadImageFinished:(UIImage *)image&#123; __block ALAssetsLibrary *lib = [[ALAssetsLibrary alloc] init]; [lib writeImageToSavedPhotosAlbum:image.CGImage metadata:nil completionBlock:^(NSURL *assetURL, NSError *error) &#123; NSLog(@"assetURL = %@, error = %@", assetURL, error); lib = nil; &#125;];&#125; 使用了ALAssetsLibrary类的writeImageToSavedPhotosAlbum:metadata:completionBlock:方法实现。其中第一个参数是一个CGImageRef的对象，表示要传入的图片。第二个参数是图片的一些属性，这里没有设置所以传入nil。最后一个completionBlock是保存完成后的回调，在这个回调中可以取到保存后的图片路径以及保存失败时的错误信息。 注意：使用该类时需要导入AssetsLibrary.framework。而且该类需要在iOS4.0以上可以使用，但是在iOS9.0之后就被标记为过时方法。官方建议使用Photos.framework中的PHPhotoLibrary进行代替，也就是下面所说的第三种方法。 第三种使用Photos框架的PHPhotoLibrary类来实现保存到相册功能。代码如下： - (void)loadImageFinished:(UIImage *)image&#123; [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123; /写入图片到相册 PHAssetChangeRequest *req = [PHAssetChangeRequest creationRequestForAssetFromImage:image]; &#125; completionHandler:^(BOOL success, NSError * _Nullable error) &#123; NSLog(@"success = %d, error = %@", success, error); &#125;];&#125; 该例子中先调用PHPhotoLibrary类的performChanges:completionHandler:方法，然后在它的changeBlock中，通过PHAssetChangeRequest类的creationRequestForAssetFromImage:方法传入一个图片对象即可实现保存到相册的功能。然后completionHandler中会告诉我们是否操作成功。 进阶使用：得到保存到相册的图片对象 也许会有人需要在保存相册后得到图片的PHAsset对象来进行后续操作（昨天刚好碰到有朋友遇到这样的问题）。那么，这里对上面例子进行改进，在创建PHAssetChangeRequest后将它的placeholderForCreatedAsset属性的localIdentifier属性保存到一个数组中，等待操作完成后再通过这个数组来查找刚刚添加的图片对象。请看下面例子： - (void)loadImageFinished:(UIImage *)image&#123; NSMutableArray *imageIds = [NSMutableArray array]; [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123; //写入图片到相册 PHAssetChangeRequest *req = [PHAssetChangeRequest creationRequestForAssetFromImage:image]; //记录本地标识，等待完成后取到相册中的图片对象 [imageIds addObject:req.placeholderForCreatedAsset.localIdentifier]; &#125; completionHandler:^(BOOL success, NSError * _Nullable error) &#123; NSLog(@"success = %d, error = %@", success, error); if (success) &#123; //成功后取相册中的图片对象 __block PHAsset *imageAsset = nil; PHFetchResult *result = [PHAsset fetchAssetsWithLocalIdentifiers:imageIds options:nil]; [result enumerateObjectsUsingBlock:^(PHAsset * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; imageAsset = obj; *stop = YES; &#125;]; if (imageAsset) &#123; //加载图片数据 [[PHImageManager defaultManager] requestImageDataForAsset:imageAsset options:nil resultHandler:^(NSData * _Nullable imageData, NSString * _Nullable dataUTI, UIImageOrientation orientation, NSDictionary * _Nullable info) &#123; NSLog("imageData = %@", imageData); &#125;]; &#125; &#125; &#125;];&#125; 总结第一种方式是最常用的，使用起来很方便，传入UIImage就可以了，也不需要担心iOS不同版本的问题。唯一缺点就是无法找到对应添加的图片。 第二种方式是iOS4之后加入的，在iOS9后又不推荐使用了。他也提供了很直观的方式来保存图片，并且也能够取到保存后相对应的图片路径。 第三种方式是iOS8之后加入的，他的使用稍微复杂一点，但是它允许进行批量的操作，例如添加、修改、删除等。如果要做更近复杂的操作的话，这种方式是比较推荐的方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS常用的判断方法]]></title>
      <url>%2F2017%2F02%2F14%2FiOS%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 ios常用的一些判断根据日起计算是周几+ (NSString*)weekdayStringFromDate:(NSDate*)inputDate&#123; NSArray *weekdays = [NSArray arrayWithObjects: [NSNull null], @"周日", @"周一", @"周二", @"周三", @"周四", @"周五", @"周六", nil]; NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar]; NSTimeZone *timeZone = [[NSTimeZone alloc] initWithName:@"Asia/Shanghai"]; [calendar setTimeZone: timeZone]; NSCalendarUnit calendarUnit = NSWeekdayCalendarUnit; NSDateComponents *theComponents = [calendar components:calendarUnit fromDate:inputDate];return [weekdays objectAtIndex:theComponents.weekday];&#125; 把时间戳转化为字符串传个时间转化为字符串+ (NSString *)dateStringFromNumberTimer:(NSString *)timerStr &#123; //转化为Double double t = [timerStr doubleValue]; //计算出距离1970的NSDate NSDate *date = [NSDate dateWithTimeIntervalSince1970:t]; //转化为 时间格式化字符串 //NSDateFormatter *df = [[[NSDateFormatter alloc] init] autorelease]; NSDateFormatter *df = [[NSDateFormatter alloc] init]; df.dateFormat = @"yyyy-MM-dd HH:mm:ss"; //转化为 时间字符串 return [df stringFromDate:date];&#125; 计算时间差获得当前系统时间到指定时间的时间差字符串,传入目标时间字符串和格式 +(NSString*)stringNowToDate:(NSString*)toDate formater:(NSString*)formatStr&#123;NSDateFormatter *formater=[[NSDateFormatter alloc] init];if (formatStr) &#123; [formater setDateFormat:formatStr];&#125;else&#123; [formater setDateFormat:[NSString stringWithFormat:@"yyyy-MM-dd HH:mm:ss"]];&#125;NSDate *date=[formater dateFromString:toDate];return [self stringNowToDate:date];&#125; 获得到指定时间的时间差字符串,格式在此方法内返回前自己根据需要格式化 +(NSString*)stringNowToDate:(NSDate*)toDate&#123; //创建日期 NSCalendar对象 NSCalendar *cal = [NSCalendar currentCalendar]; //得到当前时间 NSDate *today = [NSDate date];//用来得到具体的时差,位运算unsigned int unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit ;if (toDate &amp;&amp; today) &#123;//不为nil进行转化 NSDateComponents *d = [cal components:unitFlags fromDate:today toDate:toDate options:0 ]; //NSString *dateStr=[NSString stringWithFormat:@"%d年%d月%d日%d时%d分%d秒",[d year],[d month], [d day], [d hour], [d minute], [d second]]; NSString *dateStr=[NSString stringWithFormat:@"%02ld:%02ld:%02ld",[d hour], [d minute], [d second]]; return dateStr;&#125;return @"";&#125; 动态计算行高根据字符串的实际内容大小，在固定的宽度和大小的情况下，动态计算行高 + (CGFloat)textHeightFromTextString:(NSString *)text width:(CGFloat)textWidth fontSize:(CGFloat)size&#123; if ([MZLUtility getCurrentIOS] &gt;= 7.0) &#123; //iOS7之后 /* 第一个参数: 预设空间 宽度固定 高度预设 一个最大值 第二个参数: 行间距 如果超出范围是否截断 第三个参数: 属性字典 可以设置字体大小 */ NSDictionary *dict = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:size]&#125;; CGRect rect = [text boundingRectWithSize:CGSizeMake(textWidth, MAXFLOAT) options:NSStringDrawingTruncatesLastVisibleLine|NSStringDrawingUsesFontLeading|NSStringDrawingUsesLineFragmentOrigin attributes:dict context:nil]; //返回计算出的行高 return rect.size.height; &#125;else &#123; //iOS7之前 /* 1.第一个参数 设置的字体固定大小 2.预设 宽度和高度 宽度是固定的 高度一般写成最大值 3.换行模式 字符换行 */ CGSize textSize = [text sizeWithFont:[UIFont systemFontOfSize:size] constrainedToSize:CGSizeMake(textWidth, MAXFLOAT) lineBreakMode:NSLineBreakByCharWrapping]; return textSize.height;//返回 计算出得行高 &#125;&#125; 获取iOS的版本号+ (double)getCurrentIOS &#123; return [[[UIDevice currentDevice] systemVersion] doubleValue];&#125;+ (CGSize)getScreenSize &#123; return [[UIScreen mainScreen] bounds].size;&#125; 目录找到沙盒的路径+ (NSString *)getFullPathWithFile:(NSString *)urlName &#123;//先获取 沙盒中的Library/Caches/路径NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];NSString *myCacheDirectory = [docPath stringByAppendingPathComponent:@"MyCaches"];//检测MyCaches 文件夹是否存在if (![[NSFileManager defaultManager] fileExistsAtPath:myCacheDirectory]) &#123; //不存在 那么创建 [[NSFileManager defaultManager] createDirectoryAtPath:myCacheDirectory withIntermediateDirectories:YES attributes:nil error:nil];&#125;//用md5进行 加密 转化为 一串十六进制数字 (md5加密可以把一个字符串转化为一串唯一的用十六进制表示的串)NSString * newName = MD5Hash(urlName);//拼接路径return [myCacheDirectory stringByAppendingPathComponent:newName];&#125; 清除缓存+ (void) resetCache &#123; [[NSFileManager defaultManager] removeItemAtPath:[MZLCache cacheDirectory] error:nil];&#125; 缓存目录+ (NSString*) cacheDirectory &#123; NSArray* paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString *cacheDirectory = [paths objectAtIndex:0]; cacheDirectory = [cacheDirectory stringByAppendingPathComponent:@"MZLCaches"]; return cacheDirectory;&#125; 删除指定的缓存+ (NSData*) objectForKey:(NSString*)key &#123; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *filename = [self.cacheDirectory stringByAppendingPathComponent:key]; if ([fileManager fileExistsAtPath:filename]) &#123; NSDate *modificationDate = [[fileManager attributesOfItemAtPath:filename error:nil] objectForKey:NSFileModificationDate]; if ([modificationDate timeIntervalSinceNow] &gt; cacheTime) &#123; [fileManager removeItemAtPath:filename error:nil]; &#125; else &#123; NSData *data = [NSData dataWithContentsOfFile:filename]; return data; &#125; &#125; return nil;&#125; 创建指定的缓存+ (void) setObject:(NSData*)data forKey:(NSString*)key &#123; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *filename = [self.cacheDirectory stringByAppendingPathComponent:key]; BOOL isDir = YES; if (![fileManager fileExistsAtPath:self.cacheDirectory isDirectory:&amp;isDir]) &#123; [fileManager createDirectoryAtPath:self.cacheDirectory withIntermediateDirectories:NO attributes:nil error:nil]; &#125; NSError *error; @try &#123; [data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]; &#125; @catch (NSException * e) &#123; //TODO: error handling maybe &#125;&#125; 获取某个路径下文件的大小+ (long long) fileSizeAtPath:(NSString*) filePath&#123; NSFileManager* manager = [NSFileManager defaultManager]; if ([manager fileExistsAtPath:filePath])&#123; return [[manager attributesOfItemAtPath:filePath error:nil] fileSize];&#125;return 0;&#125; 获取缓存的大小+ (float ) folderSizeAtPath:(NSString*) folderPath&#123; NSFileManager* manager = [NSFileManager defaultManager]; if (![manager fileExistsAtPath:folderPath]) return 0; NSEnumerator *childFilesEnumerator = [[manager subpathsAtPath:folderPath] objectEnumerator]; NSString* fileName; long long folderSize = 0; while ((fileName = [childFilesEnumerator nextObject]) != nil)&#123; NSString* fileAbsolutePath = [folderPath stringByAppendingPathComponent:fileName]; folderSize += [MZLCache fileSizeAtPath:fileAbsolutePath]; &#125; return folderSize/(1024.0*1024.0);&#125; MD5加密字符串NSString * MD5Hash(NSString *aString) &#123; const char *cStr = [aString UTF8String]; unsigned char result[16]; CC_MD5( cStr, (CC_LONG)strlen(cStr), result ); return [NSString stringWithFormat:@"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X", result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7], result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15]];&#125; 正则判断手机格式的正则判断+ (BOOL)isMobileNumber:(NSString *)mobileNum&#123; /** * 手机号码 * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188 * 联通：130,131,132,152,155,156,185,186 * 电信：133,1349,153,180,189,181 * 新增：14_,17_ */ NSString * MOBIL = @"^1(3[0-9]|4[0-9]|5[0-35-9]|7[0-9]|8[025-9])\\d&#123;8&#125;$"; /** 10 * 中国移动：China Mobile 11 * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188 12 */ NSString * CM = @"^1(34[0-8]|(3[5-9]|5[017-9]|8[2378])\\d)\\d&#123;7&#125;$"; /** 15 * 中国联通：China Unicom 16 * 130,131,132,152,155,156,185,186 17 */ NSString * CU = @"^1(3[0-2]|5[256]|8[56])\\d&#123;8&#125;$"; /** 20 * 中国电信：China Telecom 21 * 133,1349,153,180,189,181(增加) 22 */ NSString * CT = @"^1((33|53|8[019])[0-9]|349)\\d&#123;7&#125;$"; /** 25 * 大陆地区固话及小灵通 26 * 区号：010,020,021,022,023,024,025,027,028,029 27 * 号码：七位或八位 28 */ // NSString * PHS = @"^0(10|2[0-5789]|\\d&#123;3&#125;)\\d&#123;7,8&#125;$"; NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", MOBIL]; NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM]; NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU]; NSPredicate *regextestct = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT]; if (([regextestmobile evaluateWithObject:mobileNum] || [regextestcm evaluateWithObject:mobileNum] || [regextestct evaluateWithObject:mobileNum] || [regextestcu evaluateWithObject:mobileNum])) &#123; return YES; &#125; return NO;&#125; 密码正则判断6-16 大小写数字+ (BOOL) isPassword:(NSString *)password;&#123; NSRegularExpression *regularexpression = [[NSRegularExpression alloc] initWithPattern:@"^[a-zA-Z0-9]&#123;6,16&#125;$" options:NSRegularExpressionCaseInsensitive error:nil]; NSUInteger numberofMatch = [regularexpression numberOfMatchesInString:password options:NSMatchingReportProgress range:NSMakeRange(0, password.length)]; if(numberofMatch &gt; 0) return YES; return NO; 邮箱的正则判断+ (BOOL) isEmail:(NSString *)email&#123; NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;"; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex]; if ([emailTest evaluateWithObject:email]) &#123; return YES; &#125; return NO;&#125; 身份证正则判断+ (BOOL) isIdentityCard: (NSString *)identityCard&#123; NSString *idnum = @"^(\\d&#123;14&#125;|\\d&#123;17&#125;)(\\d|[xX])$"; NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",idnum]; return [identityCardPredicate evaluateWithObject:identityCard];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[类别]]></title>
      <url>%2F2017%2F02%2F14%2F%E7%B1%BB%E5%88%AB%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 类别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序]]></title>
      <url>%2F2017%2F02%2F14%2F%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 数组排序取同一天NSMutableArray *dateMutablearray = [@[] mutableCopy]; NSArray *array1 = @[@"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-04",@"2014-04-06",@"2014-04-08", @"2014-04-05",@"2014-04-07",@"2014-04-09",]; NSMutableArray *array = [NSMutableArray arrayWithArray:array1]; for (int i = 0; i &lt; array.count; i ++) &#123; NSString *string = array[ i]; NSMutableArray *tempArray = [@[] mutableCopy]; [tempArray addObject:string]; for (int j = i+1; j &lt; array.count; j ++) &#123; NSString *jstring = array[j]; NSLog(@"jstring:%@",jstring); if([string isEqualToString:jstring])&#123; NSLog(@"jvalue = kvalue"); [tempArray addObject:jstring]; [array removeObjectAtIndex:j]; &#125; &#125; [dateMutablearray addObject:tempArray]; &#125;NSLog(@"array:%@",array); NSLog(@"dateMutable:%@",dateMutablearray);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客搭建]]></title>
      <url>%2F2017%2F02%2F07%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 github部分登录 注册https://github.com/Sign up : 注册sign in : 登陆 建立远程仓库注意命名格式 Github名＋.github.io 配置SSH key$ ssh-keygen -t rsa -C "这里是你Github绑定的邮箱我的是QQ邮箱@qq.com" 如果你已经配置过，会提示是否覆盖y／n，直接输入y代表覆盖，生成新的秘钥，其余return就可以。秘钥生成配置成功标志。 +—[RSA 2048]——+| ..+ o || . O.= + || . . . o.oB O o || . + o o=. * * || = o .So. + || . + . . . ||. . o . . .. || o o.o E +. . ||o .o*o. . oo |+——[SHA256]——+ 找到公钥点击mac的空白处，电脑最上面前往打开，前往文件夹，或者快捷键 shift +commond +g 前往--&gt;前往文件夹－－&gt;输入 ~/.ssh/id_rsa.pub 复制公钥，前往Github配置 博客仓库（dingxp.github.io）--&gt;点击settings --&gt;左侧 Deploy keys存在就删除，不存在就加上 刚才的公钥，key的名字随便写 关联Github后面步骤中，当你发布文章Git终端执行hexo d的时候提示 Username for 'https://github.com':Password for 'https://github.com': hexo部分安装homebrew]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[丁旭朋]]></title>
      <url>%2F2017%2F02%2F06%2F%E4%B8%81%E6%97%AD%E6%9C%8B%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F06%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
