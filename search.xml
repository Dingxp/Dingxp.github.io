<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS常用的判断方法]]></title>
      <url>%2F2017%2F02%2F14%2FiOS%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 ios常用的一些判断根据日起计算是周几+ (NSString*)weekdayStringFromDate:(NSDate*)inputDate&#123; NSArray *weekdays = [NSArray arrayWithObjects: [NSNull null], @"周日", @"周一", @"周二", @"周三", @"周四", @"周五", @"周六", nil]; NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar]; NSTimeZone *timeZone = [[NSTimeZone alloc] initWithName:@"Asia/Shanghai"]; [calendar setTimeZone: timeZone]; NSCalendarUnit calendarUnit = NSWeekdayCalendarUnit; NSDateComponents *theComponents = [calendar components:calendarUnit fromDate:inputDate];return [weekdays objectAtIndex:theComponents.weekday];&#125; 把时间戳转化为字符串传个时间转化为字符串+ (NSString *)dateStringFromNumberTimer:(NSString *)timerStr &#123; //转化为Double double t = [timerStr doubleValue]; //计算出距离1970的NSDate NSDate *date = [NSDate dateWithTimeIntervalSince1970:t]; //转化为 时间格式化字符串 //NSDateFormatter *df = [[[NSDateFormatter alloc] init] autorelease]; NSDateFormatter *df = [[NSDateFormatter alloc] init]; df.dateFormat = @"yyyy-MM-dd HH:mm:ss"; //转化为 时间字符串 return [df stringFromDate:date];&#125; 计算时间差获得当前系统时间到指定时间的时间差字符串,传入目标时间字符串和格式 +(NSString*)stringNowToDate:(NSString*)toDate formater:(NSString*)formatStr&#123;NSDateFormatter *formater=[[NSDateFormatter alloc] init];if (formatStr) &#123; [formater setDateFormat:formatStr];&#125;else&#123; [formater setDateFormat:[NSString stringWithFormat:@"yyyy-MM-dd HH:mm:ss"]];&#125;NSDate *date=[formater dateFromString:toDate];return [self stringNowToDate:date];&#125; 获得到指定时间的时间差字符串,格式在此方法内返回前自己根据需要格式化 +(NSString*)stringNowToDate:(NSDate*)toDate&#123; //创建日期 NSCalendar对象 NSCalendar *cal = [NSCalendar currentCalendar]; //得到当前时间 NSDate *today = [NSDate date];//用来得到具体的时差,位运算unsigned int unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit ;if (toDate &amp;&amp; today) &#123;//不为nil进行转化 NSDateComponents *d = [cal components:unitFlags fromDate:today toDate:toDate options:0 ]; //NSString *dateStr=[NSString stringWithFormat:@"%d年%d月%d日%d时%d分%d秒",[d year],[d month], [d day], [d hour], [d minute], [d second]]; NSString *dateStr=[NSString stringWithFormat:@"%02ld:%02ld:%02ld",[d hour], [d minute], [d second]]; return dateStr;&#125;return @"";&#125; 动态计算行高根据字符串的实际内容大小，在固定的宽度和大小的情况下，动态计算行高 + (CGFloat)textHeightFromTextString:(NSString *)text width:(CGFloat)textWidth fontSize:(CGFloat)size&#123; if ([MZLUtility getCurrentIOS] &gt;= 7.0) &#123; //iOS7之后 /* 第一个参数: 预设空间 宽度固定 高度预设 一个最大值 第二个参数: 行间距 如果超出范围是否截断 第三个参数: 属性字典 可以设置字体大小 */ NSDictionary *dict = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:size]&#125;; CGRect rect = [text boundingRectWithSize:CGSizeMake(textWidth, MAXFLOAT) options:NSStringDrawingTruncatesLastVisibleLine|NSStringDrawingUsesFontLeading|NSStringDrawingUsesLineFragmentOrigin attributes:dict context:nil]; //返回计算出的行高 return rect.size.height; &#125;else &#123; //iOS7之前 /* 1.第一个参数 设置的字体固定大小 2.预设 宽度和高度 宽度是固定的 高度一般写成最大值 3.换行模式 字符换行 */ CGSize textSize = [text sizeWithFont:[UIFont systemFontOfSize:size] constrainedToSize:CGSizeMake(textWidth, MAXFLOAT) lineBreakMode:NSLineBreakByCharWrapping]; return textSize.height;//返回 计算出得行高 &#125;&#125; 获取iOS的版本号+ (double)getCurrentIOS &#123; return [[[UIDevice currentDevice] systemVersion] doubleValue];&#125;+ (CGSize)getScreenSize &#123; return [[UIScreen mainScreen] bounds].size;&#125; 目录找到沙盒的路径+ (NSString *)getFullPathWithFile:(NSString *)urlName &#123;//先获取 沙盒中的Library/Caches/路径NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];NSString *myCacheDirectory = [docPath stringByAppendingPathComponent:@"MyCaches"];//检测MyCaches 文件夹是否存在if (![[NSFileManager defaultManager] fileExistsAtPath:myCacheDirectory]) &#123; //不存在 那么创建 [[NSFileManager defaultManager] createDirectoryAtPath:myCacheDirectory withIntermediateDirectories:YES attributes:nil error:nil];&#125;//用md5进行 加密 转化为 一串十六进制数字 (md5加密可以把一个字符串转化为一串唯一的用十六进制表示的串)NSString * newName = MD5Hash(urlName);//拼接路径return [myCacheDirectory stringByAppendingPathComponent:newName];&#125; 清除缓存+ (void) resetCache &#123; [[NSFileManager defaultManager] removeItemAtPath:[MZLCache cacheDirectory] error:nil];&#125; 缓存目录+ (NSString*) cacheDirectory &#123; NSArray* paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString *cacheDirectory = [paths objectAtIndex:0]; cacheDirectory = [cacheDirectory stringByAppendingPathComponent:@"MZLCaches"]; return cacheDirectory;&#125; 删除指定的缓存+ (NSData*) objectForKey:(NSString*)key &#123; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *filename = [self.cacheDirectory stringByAppendingPathComponent:key]; if ([fileManager fileExistsAtPath:filename]) &#123; NSDate *modificationDate = [[fileManager attributesOfItemAtPath:filename error:nil] objectForKey:NSFileModificationDate]; if ([modificationDate timeIntervalSinceNow] &gt; cacheTime) &#123; [fileManager removeItemAtPath:filename error:nil]; &#125; else &#123; NSData *data = [NSData dataWithContentsOfFile:filename]; return data; &#125; &#125; return nil;&#125; 创建指定的缓存+ (void) setObject:(NSData*)data forKey:(NSString*)key &#123; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *filename = [self.cacheDirectory stringByAppendingPathComponent:key]; BOOL isDir = YES; if (![fileManager fileExistsAtPath:self.cacheDirectory isDirectory:&amp;isDir]) &#123; [fileManager createDirectoryAtPath:self.cacheDirectory withIntermediateDirectories:NO attributes:nil error:nil]; &#125; NSError *error; @try &#123; [data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]; &#125; @catch (NSException * e) &#123; //TODO: error handling maybe &#125;&#125; 获取某个路径下文件的大小+ (long long) fileSizeAtPath:(NSString*) filePath&#123; NSFileManager* manager = [NSFileManager defaultManager]; if ([manager fileExistsAtPath:filePath])&#123; return [[manager attributesOfItemAtPath:filePath error:nil] fileSize];&#125;return 0;&#125; 获取缓存的大小+ (float ) folderSizeAtPath:(NSString*) folderPath&#123; NSFileManager* manager = [NSFileManager defaultManager]; if (![manager fileExistsAtPath:folderPath]) return 0; NSEnumerator *childFilesEnumerator = [[manager subpathsAtPath:folderPath] objectEnumerator]; NSString* fileName; long long folderSize = 0; while ((fileName = [childFilesEnumerator nextObject]) != nil)&#123; NSString* fileAbsolutePath = [folderPath stringByAppendingPathComponent:fileName]; folderSize += [MZLCache fileSizeAtPath:fileAbsolutePath]; &#125; return folderSize/(1024.0*1024.0);&#125; MD5加密字符串NSString * MD5Hash(NSString *aString) &#123; const char *cStr = [aString UTF8String]; unsigned char result[16]; CC_MD5( cStr, (CC_LONG)strlen(cStr), result ); return [NSString stringWithFormat:@"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X", result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7], result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15]];&#125; 正则判断手机格式的正则判断+ (BOOL)isMobileNumber:(NSString *)mobileNum&#123; /** * 手机号码 * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188 * 联通：130,131,132,152,155,156,185,186 * 电信：133,1349,153,180,189,181 * 新增：14_,17_ */ NSString * MOBIL = @"^1(3[0-9]|4[0-9]|5[0-35-9]|7[0-9]|8[025-9])\\d&#123;8&#125;$"; /** 10 * 中国移动：China Mobile 11 * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188 12 */ NSString * CM = @"^1(34[0-8]|(3[5-9]|5[017-9]|8[2378])\\d)\\d&#123;7&#125;$"; /** 15 * 中国联通：China Unicom 16 * 130,131,132,152,155,156,185,186 17 */ NSString * CU = @"^1(3[0-2]|5[256]|8[56])\\d&#123;8&#125;$"; /** 20 * 中国电信：China Telecom 21 * 133,1349,153,180,189,181(增加) 22 */ NSString * CT = @"^1((33|53|8[019])[0-9]|349)\\d&#123;7&#125;$"; /** 25 * 大陆地区固话及小灵通 26 * 区号：010,020,021,022,023,024,025,027,028,029 27 * 号码：七位或八位 28 */ // NSString * PHS = @"^0(10|2[0-5789]|\\d&#123;3&#125;)\\d&#123;7,8&#125;$"; NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", MOBIL]; NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM]; NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU]; NSPredicate *regextestct = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT]; if (([regextestmobile evaluateWithObject:mobileNum] || [regextestcm evaluateWithObject:mobileNum] || [regextestct evaluateWithObject:mobileNum] || [regextestcu evaluateWithObject:mobileNum])) &#123; return YES; &#125; return NO;&#125; 密码正则判断6-16 大小写数字+ (BOOL) isPassword:(NSString *)password;&#123; NSRegularExpression *regularexpression = [[NSRegularExpression alloc] initWithPattern:@"^[a-zA-Z0-9]&#123;6,16&#125;$" options:NSRegularExpressionCaseInsensitive error:nil]; NSUInteger numberofMatch = [regularexpression numberOfMatchesInString:password options:NSMatchingReportProgress range:NSMakeRange(0, password.length)]; if(numberofMatch &gt; 0) return YES; return NO; 邮箱的正则判断+ (BOOL) isEmail:(NSString *)email&#123; NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;"; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex]; if ([emailTest evaluateWithObject:email]) &#123; return YES; &#125; return NO;&#125; 身份证正则判断+ (BOOL) isIdentityCard: (NSString *)identityCard&#123; NSString *idnum = @"^(\\d&#123;14&#125;|\\d&#123;17&#125;)(\\d|[xX])$"; NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",idnum]; return [identityCardPredicate evaluateWithObject:identityCard];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[类别]]></title>
      <url>%2F2017%2F02%2F14%2F%E7%B1%BB%E5%88%AB%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 类别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序]]></title>
      <url>%2F2017%2F02%2F14%2F%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 数组排序取同一天NSMutableArray *dateMutablearray = [@[] mutableCopy]; NSArray *array1 = @[@"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-01",@"2014-04-02",@"2014-04-03", @"2014-04-04",@"2014-04-06",@"2014-04-08", @"2014-04-05",@"2014-04-07",@"2014-04-09",]; NSMutableArray *array = [NSMutableArray arrayWithArray:array1]; for (int i = 0; i &lt; array.count; i ++) &#123; NSString *string = array[ i]; NSMutableArray *tempArray = [@[] mutableCopy]; [tempArray addObject:string]; for (int j = i+1; j &lt; array.count; j ++) &#123; NSString *jstring = array[j]; NSLog(@"jstring:%@",jstring); if([string isEqualToString:jstring])&#123; NSLog(@"jvalue = kvalue"); [tempArray addObject:jstring]; [array removeObjectAtIndex:j]; &#125; &#125; [dateMutablearray addObject:tempArray]; &#125;NSLog(@"array:%@",array); NSLog(@"dateMutable:%@",dateMutablearray);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客搭建]]></title>
      <url>%2F2017%2F02%2F07%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[hexo+github DIY博客以下是我自己搭建免费搭建博客的大致步骤，鄙人不才，如果有失误之处，望君能指点，已经加了评论功能，可以点赞评论哦！后面博客里我少上传图片，会导致上传和显示慢，而且博客就300M。 github部分登录 注册https://github.com/Sign up : 注册sign in : 登陆 建立远程仓库注意命名格式 Github名＋.github.io 配置SSH key$ ssh-keygen -t rsa -C "这里是你Github绑定的邮箱我的是QQ邮箱@qq.com" 如果你已经配置过，会提示是否覆盖y／n，直接输入y代表覆盖，生成新的秘钥，其余return就可以。秘钥生成配置成功标志。 +—[RSA 2048]——+| ..+ o || . O.= + || . . . o.oB O o || . + o o=. * * || = o .So. + || . + . . . ||. . o . . .. || o o.o E +. . ||o .o*o. . oo |+——[SHA256]——+ 找到公钥点击mac的空白处，电脑最上面前往打开，前往文件夹，或者快捷键 shift +commond +g 前往--&gt;前往文件夹－－&gt;输入 ~/.ssh/id_rsa.pub 复制公钥，前往Github配置 博客仓库（dingxp.github.io）--&gt;点击settings --&gt;左侧 Deploy keys存在就删除，不存在就加上 刚才的公钥，key的名字随便写 关联Github后面步骤中，当你发布文章Git终端执行hexo d的时候提示 Username for 'https://github.com':Password for 'https://github.com': hexo部分安装homebrew]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[丁旭朋]]></title>
      <url>%2F2017%2F02%2F06%2F%E4%B8%81%E6%97%AD%E6%9C%8B%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F06%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
